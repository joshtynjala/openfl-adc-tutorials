<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>What is AGAL? | OpenFL Tutorials</title><link href="/css/styles.css" rel="stylesheet"></head><body><main><h1>What is AGAL?</h1><div class="main-content"><aside class="sidebar"><div class="authors"><div class="author"><img src="/articles/img/marco-scabia.png" alt="Marco Scabia"><p><cite>Original by Marco Scabia</cite></p></div><div class="author"><img src="/articles/img/josh-tynjala.jpg" alt="Josh Tynjala"><p><cite>Adapted by Josh Tynjala</cite></p></div></div><div class="toc"><h2>Content</h2><nav class="toc"><ol><li><a href="#understanding-shading-languages">Understanding Shading languages</a></li><li><a href="#overview-of-agal">Overview of AGAL</a></li><li><a href="#examining-the-syntax-of-agal">Examining the syntax of AGAL</a></li><li><a href="#identifying-the-main-opcodes-in-agal">Identifying the main opcodes in AGAL</a></li><li><a href="#working-with-agal-registers">Working with AGAL registers</a><ol><li><a href="#1.-attribute-registers">1. Attribute registers</a></li><li><a href="#2.-constant-registers">2. Constant registers</a></li><li><a href="#3.-temporary-registers">3. Temporary registers</a></li><li><a href="#4.-output-registers">4. Output registers</a></li><li><a href="#5.-varying-registers">5. Varying Registers</a></li><li><a href="#6.-texture-sampler-registers">6. Texture sampler registers</a></li></ol></li><li><a href="#creating-a-sample-agal-shader">Creating a sample AGAL shader</a></li><li><a href="#building-a-sample-openfl-app-with-program3d-and-agal-mini-assembler">Building a sample OpenFL app with Program3D and AGAL Mini Assembler</a></li><li><a href="#communicating-to-agal-with-haxe">Communicating to AGAL with Haxe</a></li><li><a href="#where-to-go-from-here">Where to go from here</a></li></ol></nav></div><div class="requirements"><h2>Requirements</h2><h3>Prerequisite knowledge</h3><p>Basic familiarity with the Stage3D API is required. Prior knowledge of working with shaders and understanding how the Programmable Function Pipeline operates is also recommended. Be sure to read first the first two tutorials in this series on Stage3D (1. <a href="/articles/how-stage3d-works/">How Stage3D works</a>, 2. <a href="/articles/vertex-and-fragment-shaders/">Vertex and Fragment Shaders</a> before following along with these instructions.</p><h3>User Level</h3><p>Intermediate</p><h3>Required Software</h3><ul><li><a href="https://haxe.org/">Haxe 4.2 or newer</a></li><li><a href="https://openfl.org/">OpenFL 9.5 or newer</a></li></ul></div></aside><article><p>In this article you'll get an introduction to working with shading languages. I'll cover the basics of using the low level shading language, called AGAL (Adobe Graphics Assembly Language) that is included with the Stage3D API. You'll learn what AGAL is, how it works, and how to use it as part of your Stage3D-based OpenFL application.</p><h3 id="understanding-shading-languages" tabindex="-1">Understanding Shading languages</h3><p>Before diving into AGAL specifically, it's a good idea to first understand what a shading language is and how you can use it to create shaders.</p><p>Shaders are not written in Haxe. They are not written in C++ either. Nor any other general purpose language.</p><p>Shaders are usually written in a special language, called a shading language.</p><p>Shaders are programs that run on the GPU, so the most efficient way to code a shader is to use a language that is specifically engineered with the GPU in mind. That's why you'll write shaders using these special shading languages, instead of using general purpose languages designed to code for a CPU.</p><p>There are several shading languages that have been used over the years, for the two standard native 3D platforms (OpenGL and DirectX): GLSL and HLSL are two of the most common shading languages.</p><p>The Stage3D API provides AGAL as a shading languages to create programs for the GPU.</p><h3 id="overview-of-agal" tabindex="-1">Overview of AGAL</h3><p>AGAL (Adobe Graphics Assembly Language) is an assembly language for GPU programming. It's a very low level language, that is extremely close to what the GPU actually executes. A GPU (and also a CPU for that matter) doesn't directly understand a high level kind of language like Haxe, which contains variables, classes, and so on. GPUs only understand elementary machine language commands. There is a compiler somewhere in the pipeline that translates the complex commands of the high level language, into a series of simpler, lower level machine language commands.</p><p>With AGAL, you write commands directly at the lower level, similar to the commands that the GPU understands. As a result, you get a better understanding of what's really happening in your rendering pipeline. You can hand optimize your shader instead of letting a compiler do that for you. So, as you invest more time to learn AGAL, you may be able to create better optimized shaders.</p><p>When you use AGAL, your shaders come in the form of shader program strings, that are assembled into object code at run time. So, it is possible to create AGAL shaders dynamically at runtime.</p><h3 id="examining-the-syntax-of-agal" tabindex="-1">Examining the syntax of AGAL</h3><p>AGAL is an assembly language. If you are used to the code syntax in Haxe, a language like AGAL that is an assembly might look a bit alien at first.</p><p>Here's an example of an AGAL Vertex Shader:</p><pre><code>m44 op, va0, vc0
mov v0, va1
</code></pre><p>I'll describe the syntax of the example above, so that you can decipher what each of those assembly lines means.</p><p>Every line of the shader is a command, specified by a 3 character string called opcode.</p><p>The syntax of an AGAL code line is comprised of the following:</p><pre><code>&lt;opcode&gt; &lt;destination&gt;, &lt;source 1&gt;, &lt;source 2 or sampler&gt;
</code></pre><p>This is the key. Keep this syntax in mind and AGAL will suddenly stop looking like unreadable gibberish.</p><p>Following the opcode, depending on the command, there may also be a destination, and one or two sources. The destination and the sources are called registers: small memory areas in the GPU for use by shaders. I'll cover registers in more detail later in this tutorial. The sources contain the values used in the operation, and the destination is where the result is stored.</p><h3 id="identifying-the-main-opcodes-in-agal" tabindex="-1">Identifying the main opcodes in AGAL</h3><p>AGAL features approximately 40 different opcodes. Here are some of the most common ones.</p><ul><li><code>mov:</code> moves data from source1 to destination, component-wise</li><li><code>add:</code> destination = source1 + source2, component-wise</li><li><code>sub:</code> destination = source1 – source2, component-wise</li><li><code>mul:</code> destination = source1 * source2, component-wise</li><li><code>div:</code> destination = source1 / source2, component-wise</li><li><code>dp3:</code> dot product (3 components) between source1 and source2</li><li><code>dp4:</code> dot product (4 components) between source1 and source2</li><li><code>m44:</code> multiplication between 4 components vector in source1 and 4×4 matrix in source2</li><li><code>tex:</code> texture sample. Load from texture at source2 at coordinates source1.</li></ul><p>Figure 1 and Figure 2 provide an overview of the AGAL command set.</p><p><img src="/articles/what-is-agal/fig01_large.png" alt="Figure 1. AGAL Memory, Arithmetic, Trigonometric and Algebraic related opcodes."></p><p><em>Figure 1. AGAL Memory, Arithmetic, Trigonometric and Algebraic related opcodes.</em></p><p><img src="/articles/what-is-agal/fig02_large.png" alt="Figure 2. AGAL Vector and Matrix, Conditional, and Texture Sampling Related opcodes."></p><p><em>Figure 2. AGAL Vector and Matrix, Conditional, and Texture Sampling Related opcodes.</em></p><h3 id="working-with-agal-registers" tabindex="-1">Working with AGAL registers</h3><p>AGAL doesn't use variables to store data, like Haxe and other high level languages do. AGAL just uses registers.</p><p>Registers are small memory areas in the GPU that AGAL programs (shaders) can use during their execution. Registers are used to store both the sources and the destination of AGAL commands.</p><p>You can also pass parameters to your shaders through these registers.</p><p>Each register is 128 bits wide, which means that it contains 4 floating point values. Each of these values is called a component of the register.</p><p>Register components can be accessed both through the coordinate accessors (xyzw), and through the color accessors (rgba).</p><p>The first component of a register, can be accessed like this:</p><p><register name>.x</register></p><p>As well as with this code:</p><p><register name>.r</register></p><p>Sometimes registers contain coordinate-like data, while other times they contain color data. By using the right kind of accessors, you can make your code clearer and easier to read.</p><p>Some of the opcodes above, like <code>add</code>, perform their operations component wise. This means that the addition operation is performed component by component, so that the x component is added to the x component, the y component is added to the y component, and so on.</p><p>There are six types of registers available.</p><h4 id="1.-attribute-registers" tabindex="-1">1. Attribute registers</h4><p>These registers reference the Vertex Attribute data of the VertexBuffer that is the input of the Vertex Shader. Therefore, they are only available in Vertex Shaders.</p><p>This is the main data stream that the Vertex Shader is responsible for processing. Each vertex attribute in the VertexBuffer has its own attribute register.</p><p>In order to assign a VertexBuffer attribute to a specific attribute register, use the function <code>setVertexBufferAt()</code> on a <code>Context3D</code> instance, with the proper index.</p><p>Then from the shader, access the attribute register with the syntax: <code>va&lt;n&gt;</code>, where <code>&lt;n&gt;</code> is the index number of the attribute register.</p><p>There are a total of eight attribute registers available to Vertex Shaders.</p><h4 id="2.-constant-registers" tabindex="-1">2. Constant registers</h4><p>These registers serve the purpose of passing parameters from Haxe to the shaders. This is performed with the <code>setProgramConstants()</code> family of functions on the <code>Context3D</code> class.</p><p>These registers are accessed from the shader with the syntax: <code>vc&lt;n&gt;</code> for Vertex Shaders and <code>fc&lt;n&gt;</code> for Fragment Shaders, where <code>&lt;n&gt;</code> is the index number of the constant register.</p><p>There are 128 constant registers available to Vertex Shaders, and 28 constant registers for Fragment Shaders.</p><h4 id="3.-temporary-registers" tabindex="-1">3. Temporary registers</h4><p>These registers are available to shaders, and they are used for temporary calculations. Since AGAL doesn't use variables, you'll use temporary registers to store data throughout your code.</p><p>Temporary registers are accessed with the syntax <code>vt&lt;n&gt;</code> (Vertex Shaders) and <code>ft&lt;n&gt;</code> (Fragment Shaders) where <code>&lt;n&gt;</code> is the register number.</p><p>There are 8 temporary registers available for Vertex Shaders, and 8 for Fragment Shaders.</p><h4 id="4.-output-registers" tabindex="-1">4. Output registers</h4><p>The output registers are used by Vertex and Fragment Shaders to store the output of their calculations. For Vertex Shaders, this output is the position of the vertex. For Fragment Shaders it is the color of the pixel.</p><p>These registers are accessed with the syntax <code>op</code> for Vertex Shaders, and <code>oc</code> for Fragment Shaders.</p><p>There is obviously only one output register for Vertex and for Fragment Shaders.</p><h4 id="5.-varying-registers" tabindex="-1">5. Varying Registers</h4><p>These registers are used to pass data from Vertex Shaders to Fragment Shaders. The data that is passed is properly interpolated by the GPU, so that the Fragment Shader receives the correct value for the pixel that is being processed.</p><p>Typical data that gets passed in this way is the vertex color or the UV coordinates for texturing.</p><p>These registers can be accessed with the syntax <code>v&lt;n&gt;</code>, where <code>&lt;n&gt;</code> is the register number.</p><p>There are 8 varying registers available.</p><h4 id="6.-texture-sampler-registers" tabindex="-1">6. Texture sampler registers</h4><p>Texture Sampler registers are used to pick color values from textures, based on UV coordinates.</p><p>The texture to be used is specified through Haxe with the call <code>setTextureAt()</code> on a <code>Context3D</code> instance.</p><p>The syntax for using texture samplers is: <code>fs&lt;n&gt; &lt;flags&gt;</code>, where <code>&lt;n&gt;</code> is the sampler index, and <code>&lt;flags&gt;</code> is a set of one or more flags that specifies how the sampling should be made.</p><p><code>&lt;flags&gt;</code> is a comma separated set of strings, that defines:</p><ul><li>texture dimension. Options: <code>2d</code>, <code>cube</code></li><li>mip mapping. Options: <code>nomip</code> (or <code>mipnone</code>, they are the same), <code>mipnearest</code>, <code>miplinear</code></li><li>texture filtering. Options: <code>nearest</code>, <code>linear</code></li><li>texture repeat. Options: <code>repeat</code>, <code>wrap</code>, <code>clamp</code></li></ul><p>For example, a standard 2D texture without MIP mapping and linear filtering could be sampled into temporary register <code>ft1</code>, with the following line:</p><p>tex ft1, v0, fs0 &lt;2d,linear,nomip&gt;</p><p>In the example above, the varying register <code>v0</code> holds the interpolated texture UVs.</p><h3 id="creating-a-sample-agal-shader" tabindex="-1">Creating a sample AGAL shader</h3><p>In this section, you'll go through a shader example and get a better understanding of how it operates.</p><p>Suppose the vertices in the Vertex Buffer contain vertex position, at offset 0, and vertex color, at offset 3. The code looks like this:</p><pre><code class="language-haxe">var vertices:Vector&lt;Float&gt; = Vector.ofValues(
    -0.3,-0.3, 0.0, 1.0, 0.0, 0.0, // x, y, z, r, g, b
    -0.3, 0.3, 0.0, 0.0, 1.0, 0.0,
     0.3, 0.3, 0.0, 0.0, 0.0, 1.0);
</code></pre><p>The goal is to make the Vertex Shader properly transform the vertex positions, and to pass on each vertex color to the Fragment Shader.</p><p>You can achieve this with the following code:</p><p>m44 op, va0, vc0 // pos to clipspace mov v0, va1 // copy color</p><p>The first line performs a 4×4 matrix multiplication between the vertex input attribute register 0, va0, and a transformation matrix that is being passed in from Haxe. When rendering in perspective, this is usually the transformation matrix from model space to clip space that we assume was passed from Haxe to the constant register 0, <code>vc0</code>.</p><p>Note: Clip space and perspective projection is discussed in more detail in the next tutorial in this series, titled <a href="/articles/working-with-stage3d-and-perspective-projection/">Working with Stage3D and perspective projection</a>.</p><p>The matrix can be passed to the shader, into register <code>vc0</code> with the call:</p><pre><code class="language-haxe">context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, matrix, true);
</code></pre><p>The second line of the Vertex Shader, copies the vertex color data to Varying Register 0, <code>v0</code>, so that it can get interpolated by the GPU, and passed to the Fragment Shader.</p><p>The Fragment Shader simply copies the Varying Register <code>v0</code> color content to its Output Register oc:</p><p>mov oc, v0</p><p>So, this Vertex/Fragment Shader pair just transforms the 3D model vertices using a transform matrix that gets passed in from Haxe, and applies vertex color.</p><p>This is it! Your first Vertex and Fragment Shaders.</p><h3 id="building-a-sample-openfl-app-with-program3d-and-agal-mini-assembler" tabindex="-1">Building a sample OpenFL app with Program3D and AGAL Mini Assembler</h3><p>So, how do you actually fit those bits of AGAL code into a working OpenFL application? This is where the Stage3D API comes in.</p><pre><code class="language-haxe">var program:Program3D = context3D.createProgram();
</code></pre><p>Before being able to use a <code>Program3D</code> (a shader) for rendering, you first need to upload it to the GPU. You do that by calling the <code>upload</code> method on the <code>Program3D</code> class.</p><pre><code class="language-haxe">public function upload(vertexByteCode:ByteArray, fragmentByteCode:ByteArray):Void;
```

This method call needs as input the compiled, object code, version of the Vertex
and Fragment Shaders in order to upload it to the GPU.

A good way to compile AGAL shaders into object code is to use the `openfl.utils.AGALMiniAssember` class: a utility tool that takes as input the Vertex and Fragment Shaders
source code as strings, and compiles them at runtime into object code.

So, first you are going to use AGAL Mini Assembler to compile the Vertex and
Fragment Shaders discussed above.

```haxe
var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
vertexShaderAssembler.assemble(Context3DProgramType.VERTEX,
    &quot;m44 op, va0, vc0\n&quot; + // pos to clipspace
    &quot;mov v0, va1&quot; // copy color
);
var fragmentShaderAssembler:AGALMiniAssembler= new AGALMiniAssembler();
fragmentShaderAssembler.assemble(Context3DProgramType.FRAGMENT,
    &quot;mov oc, v0&quot;
);
</code></pre><p>And then upload both Vertex and Fragment Shader programs to the GPU:</p><pre><code class="language-haxe">var program:Program3D = context3D.createProgram();
program.upload(vertexShaderAssembler.agalcode, fragmentShaderAssembler.agalcode);
</code></pre><h3 id="communicating-to-agal-with-haxe" tabindex="-1">Communicating to AGAL with Haxe</h3><p>A shader doesn't live just by itself. It is used by your main Stage3D based OpenFL application. Therefore it needs the application to send to it the data that needs to processed.</p><p>In general, shaders will need VertexBuffer data (Vertex Attributes), Textures, and additional parameters that the shader may need from Haxe, such as a transform matrix.</p><p>At render time, before using a <code>Program3D</code>, and related VertexBuffers and Textures, you'll need to enable them, by using the following calls:</p><ul><li><code>Contex3D::setProgram(program:Program3D)</code></li><li><code>Context3D::setVertexBufferAt(index:Int, buffer:VertexBuffer3D, bufferOffset:Int, format:String)</code></li><li><code>Context3D::setTextureAt(sampler:Int, texture:TextureBase)</code></li></ul><p>Note that <code>setVertexBufferAt</code> enables a specific Vertex Attribute at a certain offset in the Vertex Buffer (parameter 3), and associates it to an Attribute Register (stream) specified by index (first parameter).</p><p>The <code>setTextureAt</code> call enables a <code>Texture</code> and associates it with a certain Texture Sampler specified by the first parameter <code>sampler</code>.</p><p>This would be the syntax to use these calls, right before rendering:</p><pre><code class="language-haxe">// vertex position to attribute register 0
context3D.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
// assign texture to texture sampler 0
context3D.setTextureAt(0, texture);
// assign shader program
context3D.setProgram(program);
</code></pre><p>Before enabling any of these you need to make sure that they are uploaded to the GPU, by calling the respective upload methods:</p><ul><li><code>Program3D::upload()</code></li><li><code>VertexBuffer3D::uploadFromVector(data:Vector&lt;Float&gt;, startVertex:Int, numVertices:Int)</code></li><li><code>Texture::uploadFromBitmapData(source:BitmapData, miplevel:UInt = 0)</code></li></ul><p>Then you'll want to be able to pass in parameters to your shaders as constants, stored into Constant Registers. You do that with the following calls:</p><ul><li><code>Context3D::setProgramConstantsFromVector(programType:String, firstRegister:Int, data:Vector&lt;Float&gt;, numRegisters:Int = -1)</code></li><li><code>Context3D::setProgramConstantsFromMatrix(programType:String, firstRegister:Int, matrix:Matrix3D, transposedMatrix:Bool = false)</code></li></ul><p>in order to write an OpenFL <code>Vector</code> or a <code>Matrix3D</code> respectively.</p><p>So, if you need to pass in a basic rotation matrix to your shader you'll do something like this:</p><pre><code class="language-haxe">var m:Matrix3D = new Matrix3D();
m.appendRotation(Lib.getTimer() / 50.0, Vector3D.Z_AXIS);
context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, m, true);
</code></pre><p>The matrix gets stored into Constant Register 0 here, for the Vertex Shader to use.</p><h3 id="where-to-go-from-here" tabindex="-1">Where to go from here</h3><p>This article introduced you to the concept of shaders and to the AGAL shading language. Creating a shader is a required step if you want to build an OpenFL 3D application that is based on the Stage3D API. While we didn't get to build a fully working Stage3D application yet, the content of this article is a fundamental block in being able to use the Stage3D API. In the next article of this series I am going to put everything together, and show you how to build an application that uses Stage3D to render a simple geometry.</p><ul><li><a href="/articles/hello-triangle/">4. Hello Triangle</a></li><li><a href="/articles/working-with-stage3d-and-perspective-projection/">5. Working with Stage3D and perspective projection</a></li><li><a href="/articles/working-with-3d-cameras/">6. Working with 3D cameras</a></li><li><a href="/articles/mipmapping-for-smoother-textures-in-stage3d/">7. Mipmapping for smoother textures in Stage3D</a></li></ul></article></div></main></body></html>